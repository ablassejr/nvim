# Python snippets for vim-snipmate

# ── Functions ──────────────────────────────────────

snippet def "function definition"
	def ${1:name}(${2:args}):
		${0:pass}
snippet defs "method definition"
	def ${1:name}(self, ${2}):
		${0:pass}
snippet adef "async function definition"
	async def ${1:name}(${2:args}):
		${0:pass}
snippet lam "lambda expression"
	lambda ${1:x}: ${0:x}
snippet dec "decorator"
	@${1:decorator}
	def ${2:name}(${3:args}):
		${0:pass}
snippet prop "property decorator"
	@property
	def ${1:name}(self):
		return self._${1}

# ── Classes ────────────────────────────────────────

snippet cls "class definition"
	class ${1:Name}:
		def __init__(self, ${2}):
			${0:pass}
snippet clsi "class with inheritance"
	class ${1:Name}(${2:Base}):
		def __init__(self, ${3}):
			super().__init__()
			${0:pass}
snippet dc "dataclass"
	@dataclass
	class ${1:Name}:
		${0:field: type}
snippet abc "abstract base class"
	from abc import ABC, abstractmethod

	class ${1:Name}(ABC):
		@abstractmethod
		def ${2:method}(self${3}):
			${0:pass}

# ── Control flow ───────────────────────────────────

snippet if "if statement"
	if ${1:cond}:
		${0:pass}
snippet ife "if/else"
	if ${1:cond}:
		${2:pass}
	else:
		${0:pass}
snippet elif "elif clause"
	elif ${1:cond}:
		${0:pass}
snippet for "for loop"
	for ${1:item} in ${2:iterable}:
		${0:pass}
snippet fore "for enumerate"
	for ${1:i}, ${2:item} in enumerate(${3:iterable}):
		${0:pass}
snippet whl "while loop"
	while ${1:cond}:
		${0:pass}
snippet try "try/except"
	try:
		${1:pass}
	except ${2:Exception} as e:
		${0:raise}
snippet tryf "try/except/finally"
	try:
		${1:pass}
	except ${2:Exception} as e:
		${3:raise}
	finally:
		${0:pass}
snippet with "with statement"
	with ${1:ctx} as ${2:var}:
		${0:pass}

# ── Comprehensions ─────────────────────────────────

snippet lc "list comprehension"
	[${1:x} for ${2:x} in ${0:iterable}]
snippet dc "dict comprehension"
	{${1:k}: ${2:v} for ${3:item} in ${0:iterable}}
snippet sc "set comprehension"
	{${1:x} for ${2:x} in ${0:iterable}}
snippet gc "generator expression"
	(${1:x} for ${2:x} in ${0:iterable})

# ── Output / Debug ─────────────────────────────────

snippet pr "print"
	print(${0})
snippet prf "print f-string"
	print(f"${0}")
snippet bp "breakpoint"
	breakpoint()
snippet log "logger call"
	logger.${1:info}(${0:msg})
snippet pp "pprint"
	from pprint import pprint
	pprint(${0})

# ── Imports / Returns ──────────────────────────────

snippet imp "import"
	import ${0}
snippet from "from import"
	from ${1:module} import ${0:name}
snippet ret "return"
	return ${0}
snippet tp "typing import"
	from typing import ${0}

# ── Boilerplate ────────────────────────────────────

snippet main "if __name__ main"
	if __name__ == "__main__":
		${0:main()}
snippet ifmain "main with function"
	def main():
		${0:pass}

	if __name__ == "__main__":
		main()
snippet __ "dunder method"
	def __${1:init}__(self${2}):
		${0:pass}
snippet shebang "shebang line"
	#!/usr/bin/env python3
	${0}

# ── Async ──────────────────────────────────────────

snippet aw "await"
	await ${0}
snippet afor "async for"
	async for ${1:item} in ${2:iterable}:
		${0:pass}
snippet awith "async with"
	async with ${1:ctx} as ${2:var}:
		${0:pass}

# ── Testing ────────────────────────────────────────

snippet test "test function (pytest)"
	def test_${1:name}():
		${0:assert True}
snippet testc "test class (pytest)"
	class Test${1:Name}:
		def test_${2:method}(self):
			${0:assert True}
snippet fixture "pytest fixture"
	@pytest.fixture
	def ${1:name}():
		${0:pass}
snippet mock "mock patch"
	@mock.patch("${1:target}")
	def test_${2:name}(self, mock_${3:obj}):
		${0:pass}
